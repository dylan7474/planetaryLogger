/**
 * @file multi_alignment_finder.c
 * @brief A command-line tool to analyze a CSV file of planetary data.
 *
 * This program reads a CSV file generated by the kepler_sim_3d tool and
 * allows the user to run different types of analysis, such as finding
 * conjunctions, oppositions, squares, or the closest approach between two planets.
 *
 * Compilation:
 * gcc multi_alignment_finder.c -o multi_alignment_finder -lm
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAX_PLANETS 10
#define MAX_LINE_LEN 1024

// Struct to hold a single planet's 3D coordinates
struct PlanetPosition {
    double x, y, z;
};

// Struct to hold a full frame of data for all planets on a single day
struct Frame {
    char date[11];
    struct PlanetPosition positions[MAX_PLANETS];
};

// Struct to hold a planet's name and longitude for analysis
struct PlanetData {
    char *name;
    double longitude;
};


// --- Function Prototypes ---
double angle_diff(double l1, double l2);
double distance_3d(struct PlanetPosition p1, struct PlanetPosition p2);
void find_multi_alignments(struct Frame *frames, int frame_count, char *planet_names[], int num_planets);
void find_oppositions_and_squares(struct Frame *frames, int frame_count, char *planet_names[], int num_planets);
void find_closest_approach(struct Frame *frames, int frame_count, char *planet_names[], int num_planets);


int main(void) {
    char input_filename[100];
    struct Frame *frames = NULL;
    int frame_count = 0;
    char *planet_names[MAX_PLANETS];
    int num_planets = 0;

    printf("--- Planetary Data Analysis Tool ---\n");
    printf("Enter Input CSV Filename (e.g., data_3d.csv): ");
    if (scanf("%99s", input_filename) != 1) { fprintf(stderr, "Invalid input.\n"); return 1; }

    // --- Load Data File into Memory ---
    FILE *infile = fopen(input_filename, "r");
    if (infile == NULL) {
        perror("Error opening input file");
        return 1;
    }

    char line[MAX_LINE_LEN];
    // Read header
    if (fgets(line, sizeof(line), infile)) {
        line[strcspn(line, "\n")] = 0;
        char *token = strtok(line, ","); // Skip "Date"
        while ((token = strtok(NULL, ",")) != NULL && num_planets < MAX_PLANETS) {
            char *p_name = strdup(token);
            *strchr(p_name, '_') = '\0';
            planet_names[num_planets++] = p_name;
            strtok(NULL, ","); strtok(NULL, ","); // Skip _y and _z
        }
    }

    // Read data frames
    while (fgets(line, sizeof(line), infile)) {
        frames = realloc(frames, (frame_count + 1) * sizeof(struct Frame));
        char *line_ptr = line;
        
        char *token = strsep(&line_ptr, ",");
        strncpy(frames[frame_count].date, token, 10);
        frames[frame_count].date[10] = '\0';

        for (int i = 0; i < num_planets; i++) {
            frames[frame_count].positions[i].x = atof(strsep(&line_ptr, ","));
            frames[frame_count].positions[i].y = atof(strsep(&line_ptr, ","));
            frames[frame_count].positions[i].z = atof(strsep(&line_ptr, ","));
        }
        frame_count++;
    }
    fclose(infile);
    printf("Loaded %d days of data.\n", frame_count);

    // --- Main Menu ---
    int choice = 0;
    while (choice != 4) {
        printf("\nPlease select an analysis function:\n");
        printf("  1. Find Multiple Alignments (Conjunctions)\n");
        printf("  2. Find Oppositions and Squares\n");
        printf("  3. Find Closest Approach Between Two Planets\n");
        printf("  4. Exit\n");
        printf("Enter your choice: ");
        if (scanf("%d", &choice) != 1) { choice = 0; } // Clear invalid input

        switch (choice) {
            case 1:
                find_multi_alignments(frames, frame_count, planet_names, num_planets);
                break;
            case 2:
                find_oppositions_and_squares(frames, frame_count, planet_names, num_planets);
                break;
            case 3:
                find_closest_approach(frames, frame_count, planet_names, num_planets);
                break;
            case 4:
                printf("Exiting.\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n");
                // Clear stdin buffer
                while(getchar() != '\n');
                break;
        }
    }

    // --- Cleanup ---
    for (int i = 0; i < num_planets; i++) {
        free(planet_names[i]);
    }
    free(frames);

    return 0;
}


// --- Analysis Functions ---

double angle_diff(double l1, double l2) {
    double diff = fabs(l1 - l2);
    if (diff > 180) {
        diff = 360.0 - diff;
    }
    return diff;
}

double distance_3d(struct PlanetPosition p1, struct PlanetPosition p2) {
    double dx = p1.x - p2.x;
    double dy = p1.y - p2.y;
    double dz = p1.z - p2.z;
    return sqrt(dx*dx + dy*dy + dz*dz);
}

void find_multi_alignments(struct Frame *frames, int frame_count, char *planet_names[], int num_planets) {
    double threshold;
    int min_planets;
    
    printf("\nEnter Alignment Threshold in Degrees (e.g., 5.0): ");
    if (scanf("%lf", &threshold) != 1) { fprintf(stderr, "Invalid input.\n"); return; }
    printf("Enter Minimum Planets for Alignment (e.g., 3): ");
    if (scanf("%d", &min_planets) != 1) { fprintf(stderr, "Invalid input.\n"); return; }

    printf("\n--- Found Multiple Conjunctions (Threshold: %.2f°, Min Planets: %d) ---\n", threshold, min_planets);

    for (int d = 0; d < frame_count; d++) {
        struct PlanetData day_data[MAX_PLANETS];
        for(int i=0; i < num_planets; i++) {
            day_data[i].name = planet_names[i];
            day_data[i].longitude = atan2(frames[d].positions[i].y, frames[d].positions[i].x) * 180.0 / M_PI;
            if (day_data[i].longitude < 0) day_data[i].longitude += 360;
        }

        for (int i = 0; i < num_planets; i++) {
            struct PlanetData group[MAX_PLANETS];
            int group_count = 0;
            group[group_count++] = day_data[i];

            for (int j = i + 1; j < num_planets; j++) {
                if (angle_diff(day_data[i].longitude, day_data[j].longitude) <= threshold) {
                    group[group_count++] = day_data[j];
                }
            }

            if (group_count >= min_planets) {
                printf("%s: ", frames[d].date);
                for (int k = 0; k < group_count; k++) {
                    printf("%s ", group[k].name);
                }
                printf("(within %.2f°)\n", threshold);
            }
        }
    }
    printf("--- Analysis Complete ---\n");
}

void find_oppositions_and_squares(struct Frame *frames, int frame_count, char *planet_names[], int num_planets) {
    double threshold;
    printf("\nEnter Aspect Threshold in Degrees (e.g., 5.0): ");
    if (scanf("%lf", &threshold) != 1) { fprintf(stderr, "Invalid input.\n"); return; }

    printf("\n--- Found Oppositions and Squares (Threshold: %.2f°) ---\n", threshold);

    for (int d = 0; d < frame_count; d++) {
        struct PlanetData day_data[MAX_PLANETS];
        for(int i=0; i < num_planets; i++) {
            day_data[i].name = planet_names[i];
            day_data[i].longitude = atan2(frames[d].positions[i].y, frames[d].positions[i].x) * 180.0 / M_PI;
            if (day_data[i].longitude < 0) day_data[i].longitude += 360;
        }

        for (int i = 0; i < num_planets; i++) {
            for (int j = i + 1; j < num_planets; j++) {
                double diff = angle_diff(day_data[i].longitude, day_data[j].longitude);
                
                if (fabs(diff - 180.0) <= threshold) {
                    printf("%s: %s and %s are in Opposition (%.2f° apart).\n", frames[d].date, planet_names[i], planet_names[j], diff);
                } else if (fabs(diff - 90.0) <= threshold) {
                    printf("%s: %s and %s are in a Square (%.2f° apart).\n", frames[d].date, planet_names[i], planet_names[j], diff);
                }
            }
        }
    }
    printf("--- Analysis Complete ---\n");
}


void find_closest_approach(struct Frame *frames, int frame_count, char *planet_names[], int num_planets) {
    int p1_idx = -1, p2_idx = -1;

    printf("\nSelect two planets to compare:\n");
    for (int i = 0; i < num_planets; i++) {
        printf("  %d) %s\n", i + 1, planet_names[i]);
    }
    printf("Enter number for first planet: ");
    if (scanf("%d", &p1_idx) != 1) { fprintf(stderr, "Invalid input.\n"); return; }
    printf("Enter number for second planet: ");
    if (scanf("%d", &p2_idx) != 1) { fprintf(stderr, "Invalid input.\n"); return; }

    p1_idx--; p2_idx--; // Adjust for 0-based indexing

    if (p1_idx < 0 || p1_idx >= num_planets || p2_idx < 0 || p2_idx >= num_planets || p1_idx == p2_idx) {
        fprintf(stderr, "Invalid planet selection.\n");
        return;
    }

    double min_dist = -1.0;
    char closest_date[11] = "";

    for (int d = 0; d < frame_count; d++) {
        double current_dist = distance_3d(frames[d].positions[p1_idx], frames[d].positions[p2_idx]);
        if (min_dist < 0 || current_dist < min_dist) {
            min_dist = current_dist;
            strcpy(closest_date, frames[d].date);
        }
    }

    printf("\n--- Closest Approach Found ---\n");
    printf("Planets: %s and %s\n", planet_names[p1_idx], planet_names[p2_idx]);
    printf("Date of Closest Approach: %s\n", closest_date);
    printf("Minimum Distance: %.4f AU\n", min_dist);
    printf("----------------------------\n");
}
